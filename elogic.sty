\ProvidesPackage{elogic}

\RequirePackage{ifthen}

\newboolean{dijkstra_quant} 
		% Dijkstra or Gries style quantification?
		% Dijkstra < A i: 0 ² i < n: E >
		% Gries < A i | 0 ² i < n: E >

\newboolean{parenth_quant}
		% Enclose quantification with angular brackets or parentheses?

\DeclareOption{dijkstra_quant}{\setboolean{dijkstra_quant}{false}}
\DeclareOption{parenth_quant}{\setboolean{parenth_quant}{false}}

\newcounter{subproof}
\newcounter{indent}
\newcounter{firstbranch}
\newcounter{openchange}
\newcounter{openchanged}
\setcounter{openchange}{0}
\setcounter{openchanged}{0}
\newcounter{usequotes}
\newlength{\stepspacing}
	%
	% Proof structure
	%
\newcommand{\definetabs}{  
	\setcounter{indent}{0}
	\whiledo{\value{indent} < \value{subproof}}{
		$\quad$
		\addtocounter{indent}{1}
	} 	
	$\qquad$ \= $\qquad$ \= $\quad$ \= $\qquad$ \= \kill }

	% Environment for a formal derivation
\newenvironment{deriv}[1][2mm]
{
	\setcounter{subproof}{0}
	\setcounter{firstbranch}{0}
	\setlength{\stepspacing}{#1}
	\begin{tabbing}
		\definetabs
}{	
	\end{tabbing}
}
	% One step
\newcommand{\step}[1]
{
	\ifthenelse{\value{firstbranch} = 1}
	{
		\setcounter{firstbranch}{0}
		\> $\bullet$ \> $#1$
	}{
		\> \> $#1$
	} 
	\ifthenelse{\value{openchange}=1 \OR \value{openchanged}=1}
	{
		CODE QUOTATION LEFT OPEN
		\setcounter{openchange}{0}
		\setcounter{openchanged}{0}
	}{}
}
	% A justification between two steps
\newlength{\mymy}
\newcommand{\hint}[2]{
	\settowidth{\mymy}{#2} $\ifthenelse{\lengthtest{#1 < \mymy}}{
		\setlength{\mymy}{#1}
	}{}
	\left \{\quad \parbox{\mymy}{   #2   }\quad \right \}$
}	
\newcommand{\infer}[3][2in]{ 
	\\[\stepspacing]  \> $\nospace{#2}$ \> \>  \hint{#1}{#3}  \\[\stepspacing]
}
	% Concluding note of a derivation
\newcommand{\note}[1]{
	$\qquad \qquad$ -- #1 -- 
}
	% An ad hoc derivation
\newcommand{\sidederiv}[1]
{	\addtocounter{subproof}{1}
	\setcounter{firstbranch}{1}
	\definetabs
	#1
	\setcounter{firstbranch}{1}
	\addtocounter{subproof}{-1}
	\definetabs
}
	% Add an assumption
\newcommand{\assume}[2]
{
	\> \textbf{assume} \\[\stepspacing]
	\> \> $#1$ \\
	\> \textbf{in} \\[\stepspacing]
	\addtocounter{subproof}{1}
	\definetabs
	#2
	\\[\stepspacing]
	\addtocounter{subproof}{-1}
	\definetabs
	\>  \textbf{end} \\[\stepspacing]
}

	%
	% Proof anotation
	%
\newcommand{\selectquotes}[2]{
	\ifthenelse{\value{usequotes} = 0}{#1}{#2}}
\newcommand{\changeopen}[0]{ 
	\selectquotes{ \llcorner }{''}}
\newcommand{\changeclose}[0]{ 
	\selectquotes{ \lrcorner }{''}}
\newcommand{\changedopen}[0]{ 
	\selectquotes{ \ulcorner }{} }
\newcommand{\changedclose}[0]{ 
	\selectquotes{ \urcorner }{} }
\renewcommand{\"}[0]{
	\ifthenelse{\value{openchange} = 0}{
		\setcounter{openchange}{1}
		\changeopen
	} {
		\setcounter{openchange}{0}
		\changeclose
	}
}
\renewcommand{\*}[0]{
	\ifthenelse{\value{openchanged} = 0}{
		\setcounter{openchanged}{1}
		\changedopen
	} {
		\setcounter{openchanged}{0}
		\changedclose
	}
}

	%
	% Operators of propositional and predicate logic
	%
\newboolean{usespace}
\setboolean{usespace}{true}
\newcommand{\nospace}[1]{ 
	\setboolean{usespace}{false} 
	#1 
	\setboolean{usespace}{true} 
}
\newcommand{\opspace}[2]{
	\ifthenelse{\boolean{usespace}}
	{
		\hspace{#1 mm}
		#2
		\hspace{#1 mm}
	}{
		#2
	}
}
\ifthenelse{\boolean{parenth_quant}}
{
	\newcommand{\openquant}{(}
	\newcommand{\closequant}{)}
}{
	\newcommand{\openquant}{\langle}
	\newcommand{\closequant}{\rangle}
}
\ifthenelse{\boolean{dijkstra_quant}}
{
	\newcommand{\iter}[4]{\openquant\:#1\ #2 :\ #3 :\ #4\:\closequant}
}{
	\newcommand{\iter}[4]{\openquant\:#1\ #2\ |\ #3 :\ #4\:\closequant}
}
\let\Oldland\land
	\renewcommand{\land}{ \opspace{1}{\Oldland} }
\let\OldLor\lor
	\renewcommand{\lor}{ \opspace{1}{\Oldlor} }
\renewcommand{\implies}{ \opspace{2}{\Rightarrow} }
\newcommand{\implied}{ \opspace{2}{\Leftarrow} }
\let\Oldequiv\equiv
	\renewcommand{\equiv}{ \opspace{3}{\Oldequiv}}