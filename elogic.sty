\ProvidesPackage{elogic}

\RequirePackage{ifthen}

\newboolean{dijkstra_quant} 
		% Dijkstra or Gries style quantification?
		% Dijkstra < A i: 0 ² i < n: E >
		% Gries < A i | 0 ² i < n: E >

\newboolean{parenth_quant}
		% Enclose quantification with angular brackets or parentheses?

\DeclareOption{dijkstra_quant}{\setboolean{dijkstra_quant}{false}}
\DeclareOption{parenth_quant}{\setboolean{parenth_quant}{false}}

\newcounter{subproof}
\newcounter{indent}
\newcounter{firstbranch}
\newcounter{openchange}
\newcounter{openchanged}
\setcounter{openchange}{0}
\setcounter{openchanged}{0}
\newcounter{usequotes}

	%
	% Proof structure
	%
\newcommand{\definetabs}{  
	\setcounter{indent}{0}
	\whiledo{\value{indent} < \value{subproof}}{
		$\quad$
		\addtocounter{indent}{1}
	} 	
	$\qquad$ \= $\qquad$ \= $\quad$ \= $\qquad$ \= \kill }

	% Environment for a formal derivation
\newenvironment{deriv}
{	\setcounter{subproof}{0}
	\setcounter{firstbranch}{0}
	\begin{tabbing}
		\definetabs
} {
	\end{tabbing}
}
	% One step
\newcommand{\step}[1]
{
	\ifthenelse{\value{firstbranch} = 1}
	{
		\setcounter{firstbranch}{0}
		\> $\bullet$ \> $#1$
	}{
		\> \> $#1$
	} 
	\ifthenelse{\value{openchange}=1 \OR \value{openchanged}=1}
	{
		CODE QUOTATION LEFT OPEN
		\setcounter{openchange}{0}
		\setcounter{openchanged}{0}
	}{} \\
}
	% A justification between two steps
\newcommand{\infer}[2]{ 
	\> \nospace{$#1$} \> \> \{   #2   \} \\ 
}
	% Concluding note of a derivation
\newcommand{\note}[1]{
	\> \> \> \> -- #1 -- \\
}
	% An ad hoc derivation
\newcommand{\sidederiv}[1]
{	\pushtabs
	\addtocounter{subproof}{1}
	\setcounter{firstbranch}{1}
	\definetabs
	#1
	\setcounter{firstbranch}{1}
	\addtocounter{subproof}{-1}
	\poptabs
}
	% Add an assumption
\newcommand{\assume}[2]
{
	\> \> \textbf{assume} \\
	\> \> \> $#1$ \\
	\> \> \textbf{in} \\
	\addtocounter{subproof}{1}
	\pushtabs
	\definetabs
	#2
	\poptabs
	\>  \> \textbf{end} \\
	\addtocounter{subproof}{-1}
}

	%
	% Proof anotation
	%
\newcommand{\selectquotes}[2]{
	\ifthenelse{\value{usequotes} = 0}{#1}{#2}}
\newcommand{\changeopen}[0]{ 
	\selectquotes{ \llcorner }{''}}
\newcommand{\changeclose}[0]{ 
	\selectquotes{ \lrcorner }{''}}
\newcommand{\changedopen}[0]{ 
	\selectquotes{ \ulcorner }{} }
\newcommand{\changedclose}[0]{ 
	\selectquotes{ \urcorner }{} }
\renewcommand{\"}[0]{
	\ifthenelse{\value{openchange} = 0}{
		\setcounter{openchange}{1}
		\changeopen
	} {
		\setcounter{openchange}{0}
		\changeclose
	}
}
\renewcommand{\*}[0]{
	\ifthenelse{\value{openchanged} = 0}{
		\setcounter{openchanged}{1}
		\changedopen
	} {
		\setcounter{openchanged}{0}
		\changedclose
	}
}

	%
	% Operators of propositional and predicate logic
	%
\newboolean{usespace}
\setboolean{usespace}{true}
\newcommand{\nospace}[1]{ 
	\setboolean{usespace}{false} 
	#1 
	\setboolean{usespace}{true} 
}
\newcommand{\opspace}[2]{
	\ifthenelse{\boolean{usespace}}
	{
		\hspace{#1 mm}
		#2
		\hspace{#1 mm}
	}{
		#2
	}
}
\ifthenelse{\boolean{parenth_quant}}
{
	\newcommand{\openquant}{(}
	\newcommand{\closequant}{)}
}{
	\newcommand{\openquant}{\langle}
	\newcommand{\closequant}{\rangle}
}
\ifthenelse{\boolean{dijkstra_quant}}
{
	\newcommand{\quantsep}{:}
}{
	\newcommand{\quantsep}{|}
}

\newcommand{\iter}[4]{\openquant\:#1\ #2 \quantsep \ #3 :\ #4\:\closequant}
\newcommand{\setcomp}[3]{ \{ \: #1 \quantsep \: #2 : \ #3 \: \} } 


\let\Oldland\land
%	\renewcommand{\land}{ \opspace{1}{\Oldland} }
\let\OldLor\lor
%	\renewcommand{\lor}{ \opspace{1}{\Oldlor} }
\ifthenelse{\isundefined{\implies}}
{
	\newcommand{\implies}{ \opspace{2}{\Rightarrow} }
} {
	\renewcommand{\implies}{ \opspace{2}{\Rightarrow} }
}
\newcommand{\implied}{ \opspace{2}{\Leftarrow} }
\let\Oldequiv\equiv
	\renewcommand{\equiv}{ \opspace{3}{\Oldequiv}}